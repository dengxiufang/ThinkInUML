# Think in UML 总结
===
**前言: 第一部分准备篇**

## 1 为什么需要 UML ?
### 什么是 UML ？
> UML 是一种建模的语言

> UML 定义了了一些建立模型所需要的、
表达某种特定含义的基本元素，这些元素称之为元模型，相当于语言中的基本词汇
例如，用例，类等

> UML 定义了这些元模型互相之间的关系的规则，以及如何使用这些元素
和规则绘制图形以建立模型来映射现实世界,这些规则和图形称为表示法或视图(View)
,相当于语言中的语法


### 建立模型的顺序

#### 1. 从现实世界到业务模型
>UML 提供为现实世界建立模型的元模型
* 参与者(actor)
* 用例 (use case)

#### 2. 从业务模型到概念模型(分析模型(Analysis Model))
> 绘制分析模型最主要的元模型
* 边界类(boundary)
* 实体类(entity)
* 控制类(control)
#### 3. 从概念模型到设计模型
> 概念模型的边界类可以被转化为操作界面或者系统接口
> 控制类可以被转化为计算程序或控制程序，例如工作流、算法等
> 实体类可以转化为数据库表、XML 文档或者其他带有持久化特征的类


## 2.建模基础

### 建模
#### 怎么建

> 首先寻找抽象角度，即建立这个模型的目的是什么

> 具体来说，做需求的时候，首要目标不是要弄清楚业务是如何一步一步完成的
，而是要弄清楚有多少业务的参与者？每个参与者的目标是什么？参与者的目标就是
你的抽象角度,单独分析参与者的一个个目的，这就是**用例**

#### 模是什么

> 模就是 "人" "事"，"物","规则"
* 建模公式
    * 问题领域 = 抽象角度1+抽象角度2+...+抽象角度n
    * 抽象角度 = 问题领域边界之外的参与者的业务目标 = 业务用例
    * 业务用例 = 特定场景1+特定场景2+...+特定场景n
    * 特定场景 = 静态的事物+特定的条件+特定的动作 或者
    * 特定的事 = 特定的事物+特定的规则+特定的人的行为
    
#### 用例驱动

> 推论: 要解决问题领域就要归纳出所有必要的抽象角度(用例)
为这些用例描述出可能的特定场景，并找到实现这些场景的事物、规则和行为
**用例驱动的原理**

#### 抽象层次

> 抽象层次越高，具体信息越少，但是概括能力越强，反之
* 抽象两种方法
    * 自顶向下
      > 业务建模->概念建模->系统建模->设计实现
    * 自底向上
      > 设计实现->系统建模->概念建模->业务建模
      
#### 视图，视角

> 用于组织 UML 元素,表达出模型一方面的含义

> 对于一个视图而言，不同的视角有不同的信息
    
> 建模的另一项重要工作就是为不同干系人展示它们关心的那部分视角

* 后续都带着这两个问题
**问题一: 应该为那些软件信息绘制那些视图?**
**问题二: 应该给那些干系人展示那些视角?**




